HELM:
----------

Helm is a package manager for Kubernetes. It allows you to define, install, and upgrade even the most complex Kubernetes applications.

from our exp:

We installed AWS Load Balancer Controller:

- We executed a commands and the controller was up and running with following objects in Kubernetes:
    - deployments
    - services
    - configmaps
    - secrets
    - rbac - clusterrole, clusterrolebindings, serviceaccounts

Benefits of using Helm:
- Simplifies application deployment
- Facilitates sharing and reuse of Kubernetes applications
- Enables version control of deployments

Key Concepts:
Charts: The chart is a bundle of information (Kubernetes manifest files) necessary to deploy an end to end application on Kubernetes.
Releases: Instances of a chart running in a Kubernetes cluster
Repositories: Places where charts can be placed, collected and shared

For installation follow: https://helm.sh/docs/intro/install/

Helm Architecture:
    a.) Helm CLI: The command-line client that sends commands to the Kubernetes API server.
    b.) Charts: The Helm packaging format. A chart is a collection of files that describe a related set of Kubernetes resources.
    c.) Helm Library: The underlying code that implements Helm's functionality.


Basic Helm Commands:
    - helm install: Install a chart
    - helm upgrade: Upgrade a release
    - helm rollback: Roll back a release
    - helm uninstall: Uninstall a release
    - helm list: List releases
    - helm repo: Manage chart repositories
    - helm search: Search for charts
    - helm history: Show the history of release

Creating and Publishing a Chart

handson:
    a.) Create a Simple Web Application Chart 
        - Create a new chart
            helm create simple-webapp
        - Edit simple-webapp/values.yaml
        - Edit simple-webapp/templates/deployment.yaml
        - Package the chart:
            helm package simple-webapp
        - Commit & Push the chart to your git repo


Using a Chart

    a.) Install the chart created by ourself above

        - Clone or download the chart to your local from the Git repository
        - Go to the folder where the chart exists
        - Install the chart:
            helm upgrade --install <chart-name> ./<chart-path> --set <run-time-override> -f values.yaml

            e.g.:
            helm upgrade --install my-webapp ./simple-webapp --set replicaCount=3 -f ./simple-webapp/values.dev.yaml

            helm upgrade --install my-webapp ./simple-webapp --set replicaCount=3 -f ./simple-webapp/values.qa.yaml

        - Verify the installation:
            kubectl get pods
            kubectl get services

        - Upgrade the release:
            - Change any setting in the values.dev.yaml
            - perform upgrade:
                helm upgrade --install my-webapp ./simple-webapp --set replicaCount=3 -f ./simple-webapp/values.dev.yaml

        - Perform a rollback:
            helm rollback my-webapp 1

    b.) Installing and Configuring a Public available chart. e.g. Bitnami Mysql Chart

        - Add the Bitnami repository:
            helm repo add bitnami https://charts.bitnami.com/bitnami

        - Update repositories:
            helm repo update

        - Download the MySQL chart locally for reference to work and update the values.yaml file:
            helm pull bitnami/mysql --untar --untardir ./bitnami-mysql

        - Install MySQL with custom configuration:
            helm upgrade --install my-mysql bitnami/mysql --set auth.rootPassword=secretpassword --set primary.persistence.size=10Gi

        - Verify the installation:
            kubectl get pods
            kubectl get pvc

Upgrade the installed chart essentially means upgrading the release:
        - Upgrade the release:
            helm upgrade --install my-mysql bitnami/mysql --set auth.rootPassword=newsecretpassword --set primary.persistence.size=20Gi


Best Practices

    - Use version control for your charts
    - Document your charts thoroughly
    - Use templates for reusability
    - Use CI/CD pipelines for chart testing and publishing
    - Follow Helm's chart best practices guide - share this as well

ArgoCD Overview:
----------------

ArgoCD is a declarative, GitOps continuous delivery tool for Kubernetes. 

It follows the GitOps pattern where the desired state of your applications is stored in Git, and ArgoCD ensures the actual state matches this desired state.


GitOps - Which mentions that git repository should be everyone's source of truth

continuous deployment - no manual intervention - very ideal approach - requires very thoughtful and strong processes to keep the main branch clean and deployable.

Installation: Refer the installation guide at argocd\Installation-Guide.txt

handson:
- Create a git repo // sample repo: https://github.com/aryanm12/demo-argocd
- Add Argo Application Configuration like: application.yaml
- Place K8S manifest files in it like: k8s-manifest/sample.yaml
- Apply the Argo Application file:
    - kubectl apply -f application.yaml
- Check if sync is working:
    - kubectl get application -n argocd // Status should update to Healthy
- Change replica settings at the runtime // Observe that there is no change in the cluster
- Change the replicas in the git repo // Observe auto update


Perform the same set of activities for running a Helm Chart via ArgoCD,
The sample application.yaml for Helm with ArgoCD is as follows

apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: helm-demo
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/aryanm12/demo-argocd
    path: helm-dir
    targetRevision: main
    helm:
      valueFiles:
        - values-dev.yaml
      parameters:
        - name: replicaCount
          value: "5"
  destination:
    server: https://kubernetes.default.svc
    namespace: add-your-ns
  syncPolicy:
    automated:
      prune: true
      selfHeal: true



Comprehensive CI/CD Guide for Microservices on Kubernetes:
----------------------------------------------------------

Application Architecture:
  Multi-service Architecture:
    Frontend service (Node.js)
    Backend service (Node.js)
    MongoDB database

The sample code base for this placed at: https://github.com/aryanm12/k8s-cicd-demo


Prerequisites:
  - Kubernetes cluster - > EKS
  - Jenkins server as our CICD tool
  - Container registry ECR -  Since we are working with AWS env


We will now perform the build & deployment (CICD) of 2 Sample Microservices in Kubernetes Cluster using following approaches:
a.) Standard Approach:
    CI - docker + ECR + Jenkins 
    CD - kubectl + Jenkins
b.) Helm Based:
    CI - docker + ECR + Jenkins
    CD - Helm  + Jenkins

So the CI process is common in both approaches, so Let's begin with the CI process.

- Deploy & Install Jenkins:
    - Install Java 17
    - Install Jenkins along with the necessary plugins
        - Installation Guide for debian/ubuntu: https://pkg.jenkins.io/debian-stable/
    - Run the script "jenkins-node-binaries-installation.sh" shared here to install all the required binaries in Jenkins to run the pipelines
    - Additionally Install following plugins:
        - AWS Credentials
        - Pipeline: AWS Steps

- Configure AWS credentials in Jenkins:
    - Go to "Manage Jenkins" -> "Credentials" -> System -> Global credentials (unrestricted)
    - Click on "Add Credentials"
        a.) AWS Credentials:
            Kind: AWS Credentials
            - ID: aws-credentials
            - Access Key ID: (your AWS access key)
            - Secret Access Key: (your AWS secret key)

- Create a Docker Registry in AWS ECR for Frontend and Backend images: demo-frontend and demo-backend

- Create CI pipelines for FE and BE

- Create CD Pipelines for FE, BE and MongoDB using kubectl

- Create CD Pipelines for FE, BE and MongoDb using Helm Chart



